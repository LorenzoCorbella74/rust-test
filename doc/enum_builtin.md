[back](../README.md)

# Error Handling

Con Error handling si intende il processo di gestione della possibilità che qualcosa vada storto. Rust richiede che tale pratica sia esplicita. 

In generale:
+ avere un *panic* esplicito è utile per i test e per la gestione di errori irrisolvibili.
+ Il tipo *Option* è quando un valore è opzionale o quando la mancanza di un valore non è una condizione di errore. Per le *Options*, il metodo *unwrap* è utile per prototipazzione e casi quando è assolutamente certo che ci sia un valore anche se la funzione *expect* è più utile in quanto permette di specificare un messaggio di errore nel caso le cose vadano storte.
+ Quando c'è la possibilità che le cose possano andar male ed il chiamante deve gestire il problema si deve usare *Result*. Anche per result si può usare *unwrap* e *expect* (anche se è meglio lasciarli per prototipazione).

## Panic
Il meccanismo più semplice di gestione dell'errore è detto *panic*. Stampa un messaggio di errore, e fa uscire il programma:
```rust
fn drink(beverage: &str) {
    // You shouldn't drink too much sugary beverages.
    if beverage == "lemonade" { panic!("AAAaaaaa!!!!"); }
    println!("Some refreshing {} is all I need.", beverage);
}

fn main() {
    drink("water");
    drink("lemonade");
}
```

# "BUILT-IN" Enum
Rust ha due generic enum "built in" molto importanti: 
+ Option che permette di rappresentare dei ___valori nulli senza usare null___
+ Result che permette di ritornare un valore __che ha la possibilità di fallire__

## Option
Option è usato quando l'assenza è una possibilità. Questo è molto comune nel codice, istanze di tale enum possono essere create dovunque con i due enum variants *Some(T)* quando un elemento di tipo T è trovato e *None* quando non è trovato nessun elemento. 
```rust
enum Option<T> {
  None,
    Some(T),
}
```

```rust
// A partially defined struct type
struct BagOfHolding<T> {
    // Our parameter type T can be handed to others
    item: Option<T>,
}

fn main() {
    // Note: A bag for i32, holding nothing! We have to specify the type
    // because otherwise Rust would not know what type of bag it is.
    let i32_bag = BagOfHolding::<i32> { item: None };

    if i32_bag.item.is_none() {
        println!("there's nothing in the bag!")
    } else {
        println!("there's something in the bag!")
    }

    let i32_bag = BagOfHolding::<i32> { item: Some(42) };

    if i32_bag.item.is_some() {
        println!("there's something in the bag!")
    } else {
        println!("there's nothing in the bag!")
    }

    // codice fatto girare in base al valore della variabile
    // match lets us deconstruct Option elegantly and ensure we handle all cases!
    match i32_bag.item {
        Some(v) => println!("found {} in bag!", v),
        None => println!("found nothing"),
    }
}
```
## Result
Result è il modo idiomatico con cui il linguaggio effettua la gestione degli errori.

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

Questo è molto comune nel codice, istanze di tale enum possono essere create dovunque con i due enum variants *Ok* e *Err*.

```rust
fn do_something_that_might_fail(i:i32) -> Result<f32,String> {
    if i == 42 {
        Ok(13.0)
    } else {
        Err(String::from("this is not the right number"))   
    }
}

// Main returns no value, but could return an error!
fn main() -> Result<(), String> {
    let result = do_something_that_might_fail(12);

    match result {
        Ok(v) => println!("found {}", v),
        Err(_e) => {
            // handle this error gracefully
            
            // return a new error from main that said what happened!
            return Err(String::from("something went wrong in main!"));
        }
    }

    // Notice we use a unit value inside a Result Ok
    // to represent everything is fine
    Ok(())
}
```

NB: anche la funzione main ha la possibilità di ritornare un result:

Result è così comune che Rust ha il potente operatore *?* come shortcut. 
```rust
// These two statements are equivalent:

do_something_that_might_fail()?

match do_something_that_might_fail() {
    Ok(v) => v,
    Err(e) => return Err(e),
}
```
```rust
fn do_something_that_might_fail(i: i32) -> Result<f32, String> {
    if i == 42 {
        Ok(13.0)
    } else {
        Err(String::from("this is not the right number"))
    }
}

fn main() -> Result<(), String> {
    // Look at how much code we saved!
    let v = do_something_that_might_fail(42)?;
    println!("found {}", v);
    Ok(())
}
```

## unwrap
Lavorare con Option/Result può essere tedioso quando si vuole scrivere codice "veloce". Entrambi hanno una funzione chiamata *unwrap* che può essere utile per ottenere un valore velocemente. unwrap permetterà:

+ prendere il valore dentro Option/Result
+ se l'enum è del tipo None/Err, panic!

```rust
// These two pieces of code are equivalent:

my_option.unwrap()

match my_option {
    Some(v) => v,
    None => panic!("some error message generated by Rust!"),
}

// parimenti

my_result.unwrap()

match my_result {
    Ok(v) => v,
    Err(e) => panic!("some error message generated by Rust!"),
}
```

```rust
fn do_something_that_might_fail(i: i32) -> Result<f32, String> {
    if i == 42 {
        Ok(13.0)
    } else {
        Err(String::from("this is not the right number"))
    }
}

fn main() -> Result<(), String> {
    // concise but assumptive and gets ugly fast
    let v = do_something_that_might_fail(42).unwrap();
    println!("found {}", v);
    
    // this will panic!
    let v = do_something_that_might_fail(1).unwrap();
    println!("found {}", v);
    
    Ok(())
}
```

