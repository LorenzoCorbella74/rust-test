[back](../README.md)
# "BUILT-IN" Enum

Rust ha due generic enum "built in" molto importanti: 
+ Option che permette di rappresentare dei ___valori nulli senza usare null___
+ Result che permette di ritornare un valore __che ha la possibilità di fallire__

## Option
Questo è molto comune nel codice, istanze di tale enum possono essere create dovunque con i due enum variants *Some* e *None*
```rust
enum Option<T> {
  None,
    Some(T),
}
```

```rust
// A partially defined struct type
struct BagOfHolding<T> {
    // Our parameter type T can be handed to others
    item: Option<T>,
}

fn main() {
    // Note: A bag for i32, holding nothing! We have to specify the type
    // because otherwise Rust would not know what type of bag it is.
    let i32_bag = BagOfHolding::<i32> { item: None };

    if i32_bag.item.is_none() {
        println!("there's nothing in the bag!")
    } else {
        println!("there's something in the bag!")
    }

    let i32_bag = BagOfHolding::<i32> { item: Some(42) };

    if i32_bag.item.is_some() {
        println!("there's something in the bag!")
    } else {
        println!("there's nothing in the bag!")
    }

    // codice fatto girare in base al valore della variabile
    // match lets us deconstruct Option elegantly and ensure we handle all cases!
    match i32_bag.item {
        Some(v) => println!("found {} in bag!", v),
        None => println!("found nothing"),
    }
}
```
## Result
Result è il modo idiomatico con cui il linguaggio effettua la gestione degli errori. Notare che il tipo generico ha molti tipi parametrizzati separati da virgola .

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

Questo è molto comune nel codice, istanze di tale enum possono essere create dovunque con i due enum variants *Ok* e *Err*.

```rust
fn do_something_that_might_fail(i:i32) -> Result<f32,String> {
    if i == 42 {
        Ok(13.0)
    } else {
        Err(String::from("this is not the right number"))   
    }
}

// Main returns no value, but could return an error!
fn main() -> Result<(), String> {
    let result = do_something_that_might_fail(12);

    match result {
        Ok(v) => println!("found {}", v),
        Err(_e) => {
            // handle this error gracefully
            
            // return a new error from main that said what happened!
            return Err(String::from("something went wrong in main!"));
        }
    }

    // Notice we use a unit value inside a Result Ok
    // to represent everything is fine
    Ok(())
}
```

NB: anche la funzione main ha la possibilità di ritornare un result:

Result è così comune che Rust ha il potente operatore *?* come shortcut. 
```rust
// These two statements are equivalent:

do_something_that_might_fail()?

match do_something_that_might_fail() {
    Ok(v) => v,
    Err(e) => return Err(e),
}
```
```rust
fn do_something_that_might_fail(i: i32) -> Result<f32, String> {
    if i == 42 {
        Ok(13.0)
    } else {
        Err(String::from("this is not the right number"))
    }
}

fn main() -> Result<(), String> {
    // Look at how much code we saved!
    let v = do_something_that_might_fail(42)?;
    println!("found {}", v);
    Ok(())
}
```

## unwrap
Lavorare con Option/Result può essere tedioso quando si vuole scrivere codice "veloce". Entrambi hanno una funzione chiamata *unwrap* che può essere utile per ottenere un valore velocemente. unwrap permetterà:

+ prendere il valore dentro Option/Result
+ se l'enum è del tipo None/Err, panic!

```rust
// These two pieces of code are equivalent:

my_option.unwrap()

match my_option {
    Some(v) => v,
    None => panic!("some error message generated by Rust!"),
}

// parimenti

my_result.unwrap()

match my_result {
    Ok(v) => v,
    Err(e) => panic!("some error message generated by Rust!"),
}
```

```rust
fn do_something_that_might_fail(i: i32) -> Result<f32, String> {
    if i == 42 {
        Ok(13.0)
    } else {
        Err(String::from("this is not the right number"))
    }
}

fn main() -> Result<(), String> {
    // concise but assumptive and gets ugly fast
    let v = do_something_that_might_fail(42).unwrap();
    println!("found {}", v);
    
    // this will panic!
    let v = do_something_that_might_fail(1).unwrap();
    println!("found {}", v);
    
    Ok(())
}
```

